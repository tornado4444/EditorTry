#version 460 core

#define INVALID_POINTER 0xFFFFFFFFu

struct LBVHNode {
    int left; // -1 for leaf
    int right; // -1 for leaf
    uint primitiveIdx; // 0 for inner nodes
    float aabbMinX, aabbMinY, aabbMinZ;
    float aabbMaxX, aabbMaxY, aabbMaxZ;
};

struct LBVHConstructionInfo {
    uint parent;
    int visitationCount;
};

layout(local_size_x = 256) in;

layout(std430, binding = 0) coherent buffer LBVH { 
    LBVHNode g_lbvh[]; 
};
layout(std430, binding = 1) coherent buffer LBVHConstructionInfos { 
    LBVHConstructionInfo g_lbvh_construction_infos[]; 
};

uniform uint numElements;
uniform uint absolutePointers;

void aabbUnion(vec3 minA, vec3 maxA, vec3 minB, vec3 maxB, out vec3 minAABB, out vec3 maxAABB) {
    minAABB = min(minA, minB);
    maxAABB = max(maxA, maxB);
}

void main() {
    uint gID = gl_GlobalInvocationID.x;
    const int LEAF_OFFSET = int(numElements) - 1;
    
    if (gID >= numElements) return;
    
    // Начинаем с листового узла
    uint nodeIdx = g_lbvh_construction_infos[LEAF_OFFSET + gID].parent;
    
    while (nodeIdx < numElements - 1) { // Проверка границ для внутренних узлов
        // Атомарное увеличение счетчика посещений
        int visitations = atomicAdd(g_lbvh_construction_infos[nodeIdx].visitationCount, 1);
        
        // Если это первое посещение, выходим и ждем второго потока
        if (visitations == 0) return;
        
        // Второе посещение - вычисляем AABB
        LBVHNode bvhNode = g_lbvh[nodeIdx];
        
        // Получение индексов дочерних узлов
        int leftIdx = (absolutePointers != 0) ? bvhNode.left : int(nodeIdx) + bvhNode.left;
        int rightIdx = (absolutePointers != 0) ? bvhNode.right : int(nodeIdx) + bvhNode.right;
        
        // Проверка границ
        if (leftIdx < 0 || leftIdx >= int(2 * numElements - 1) || 
            rightIdx < 0 || rightIdx >= int(2 * numElements - 1)) {
            return;
        }
        
        LBVHNode leftChild = g_lbvh[leftIdx];
        LBVHNode rightChild = g_lbvh[rightIdx];
        
        vec3 minA = vec3(leftChild.aabbMinX, leftChild.aabbMinY, leftChild.aabbMinZ);
        vec3 maxA = vec3(leftChild.aabbMaxX, leftChild.aabbMaxY, leftChild.aabbMaxZ);
        vec3 minB = vec3(rightChild.aabbMinX, rightChild.aabbMinY, rightChild.aabbMinZ);
        vec3 maxB = vec3(rightChild.aabbMaxX, rightChild.aabbMaxY, rightChild.aabbMaxZ);
        
        // Проверка на валидность AABB (не должны быть нулевыми)
        if (all(equal(minA, vec3(0.0))) && all(equal(maxA, vec3(0.0))) ||
            all(equal(minB, vec3(0.0))) && all(equal(maxB, vec3(0.0)))) {
            return; // Пропускаем невалидные AABB
        }
        
        vec3 minAABB, maxAABB;
        aabbUnion(minA, maxA, minB, maxB, minAABB, maxAABB);
        
        // Обновление AABB текущего узла
        g_lbvh[nodeIdx].aabbMinX = minAABB.x;
        g_lbvh[nodeIdx].aabbMinY = minAABB.y;
        g_lbvh[nodeIdx].aabbMinZ = minAABB.z;
        g_lbvh[nodeIdx].aabbMaxX = maxAABB.x;
        g_lbvh[nodeIdx].aabbMaxY = maxAABB.y;
        g_lbvh[nodeIdx].aabbMaxZ = maxAABB.z;
        
        // Если достигли корня, завершаем
        if (nodeIdx == 0) return;
        
        // Переход к родительскому узлу
        nodeIdx = g_lbvh_construction_infos[nodeIdx].parent;
    }
}